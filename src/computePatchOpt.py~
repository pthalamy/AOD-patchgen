#!/usr/bin/python3.4

import sys
from time import gmtime, strftime

INTERACTIVE = 0

# Open the files
originalFile = open(sys.argv[1], "r")
outputFile = open(sys.argv[2], "r")
patchFile = open("./P", "w")

# Parse the files
originalLines = originalFile.readlines()
outputLines = outputFile.readlines()

# Get number of lines in each file
N = len(originalLines)
M = len(outputLines)

if (INTERACTIVE):
    print ("Number of lines in original file : %s" %N)
    print ("Number of lines in output file : %s" %M)
    raw_input("Press [ENTER] to continue ")

# Init the matrix N*M
# Min cost
cost = [[0 for x in range(M+1)] for x in range(N+1)]
# 0 = add /// 1 = deletion /// 2 = substitution /// 3 = D-deletion /// 4 = identity
choices = [[-1 for x in range(M+1)] for x in range(N+1)]
# For D-deletion, keep number of lines deleted
nbLinesDeleted = [[0 for x in range(M+1)] for x in range(N+1)]

cost[1][0] = 10
choices[1][0] = 1
for i in range(2, N+1):
    cost[i][0] = 15
    choices[i][0] = 3
    nbLinesDeleted[i][0] = i

for j in range(1,M+1):
    cost[0][j] = cost[0][j-1] + 10 + len(outputLines[j-1])
    choices[0][j] = 0  # Useless
# Init done


# Fill cost matrix
for j in range(1, M+1):

    list_D = []
    if (j % (25*M/100) == 0):
        print  (strftime("[%H:%M]") + " Filling the matrix... " + str(j*100 / M) + "% complete")

    for i in range(1, N+1):

        # Define cost per operation
        Ca = 10 + len(outputLines[j-1])
        Cd = 10
        if (originalLines[i-1] == outputLines[j-1]):
            Cs = 0
        else:
            Cs = 10 + len(outputLines[j-1])
        CD = 15

        # Calculate min for D-deletion
        list_D = list_D + [(cost[i-1][j])]

        min_D = min(list_D) + CD
        index_min_D = list_D.index(min(list_D)) + 1

        # Calculate min
        l = [cost[i][j-1] + Ca, cost[i-1][j] + Cd, cost[i-1][j-1] + Cs, min_D]

        cost[i][j] = min(l)
        index_min_cost = l.index(min(l))

        if (index_min_cost == 2 and Cs == 0):
            index_min_cost = 4

        choices[i][j] = index_min_cost

        # If it's a D-deletion, keep the number of lines deleted
        if (index_min_cost == 3):
            nbLinesDeleted[i][j] = index_min_D

if (INTERACTIVE):
    raw_input("Press [ENTER] to continue ")

i = N
j = M
patch = []
# Calculate patch
while (i > 0  or j > 0):
    if (INTERACTIVE) :
        print(i,j)

    if (choices[i][j] == 0):
        patch = patch + [outputLines[j-1]]
        patch = patch + ["+ %d\n" %i]

        j = j-1
    elif (choices[i][j] == 1):
        patch = patch + ["d %d\n" %i]
        i = i-1
    elif (choices[i][j] == 2):
        patch = patch + [outputLines[j-1]]
        patch = patch + ["= %d\n" %i]

        i = i-1
        j = j-1
    elif (choices[i][j] == 3):
        patch = patch + ["D %d %d\n" %(i+1 - nbLinesDeleted[i][j], nbLinesDeleted[i][j])]

        i = i-nbLinesDeleted[i][j]
    elif (choices[i][j] == 4):
        i = i-1
        j = j-1
    else:
        print ("No choice possible..")
        j = j-1
        i = i-1


if (INTERACTIVE):
    print ("Cost of the patch calculated: %d" %cost[N][M])
# Write the patch
patch.reverse()
for i in range(len(patch)):
    patchFile.write(patch[i])

# Close the files
originalFile.close()
outputFile.close()
patchFile.close()
