+ 0
 /* This program is distributed under the GNU General Public License, version 2.
+ 0
 * A copy of this license is included with this source.
+ 0
 *
+ 0
 * Copyright 2000-2002, Michael Smith <msmith@xiph.org>
+ 0
 *
+ 0
 * Portions from Vorbize, (c) Kenneth Arnold <kcarnold@yahoo.com>
+ 0
 * and libvorbis examples, (c) Monty <monty@xiph.org>
+ 0
 */
+ 0
#include <alloca.h>
+ 0
#include <assert.h>
+ 0
#include <ctype.h>
+ 0
#include <errno.h>
+ 0
#include <fcntl.h>
+ 0
#include <stdio.h>
+ 0
#include <stdlib.h>
+ 0
#include <string.h>
+ 0
#include <sys/stat.h>
+ 0
#include <sys/time.h>
+ 0
#include <sys/types.h>
+ 0
#include <time.h>
+ 0
#include <unistd.h>
+ 0

+ 0
struct option
+ 0
{
+ 0
# if (defined __STDC__ && __STDC__) || defined __cplusplus
+ 0
  const char *name;
+ 0
# else
+ 0
  char *name;
+ 0
# endif
+ 0
  /* has_arg can't be an enum because some compilers complain about
+ 0
     type mismatches in all the code that assumes it is an int.  */
+ 0
  int has_arg;
+ 0
  int *flag;
+ 0
  int val;
+ 0
};
+ 0

+ 0
# define no_argument            0
+ 0
# define required_argument      1
+ 0
# define optional_argument      2
+ 0

+ 0
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts);
+ 0
extern int getopt_long (int ___argc, char *const *___argv,
+ 0
                        const char *__shortopts,
+ 0
                        const struct option *__longopts, int *__longind);
+ 0
extern int getopt_long_only (int ___argc, char *const *___argv,
+ 0
                             const char *__shortopts,
+ 0
                             const struct option *__longopts, int *__longind);
+ 0

+ 0
extern int _getopt_internal (int ___argc, char *const *___argv,
+ 0
                             const char *__shortopts,
+ 0
                             const struct option *__longopts, int *__longind,
+ 0
                             int __long_only);
+ 0

+ 0

+ 0
#define setbinmode(x) {}
+ 0
#define DEFAULT_NAMEFMT_REMOVE "/"
+ 0
#define DEFAULT_NAMEFMT_REPLACE NULL
+ 0

+ 0
#struct option
+ 0
{
+ 0
# if (defined __STDC__ && __STDC__) || defined __cplusplus
+ 0
  const char *name;
+ 0
# else
+ 0
  char *name;
+ 0
# endif
+ 0
  /* has_arg can't be an enum because some compilers complain about
+ 0
     type mismatches in all the code that assumes it is an int.  */
+ 0
  int has_arg;
+ 0
  int *flag;
+ 0
  int val;
+ 0
};
+ 0

+ 0
define __ENCODE_H
+ 0

+ 0
/********************************************************************
+ 0
 *                                                                  *
+ 0
 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
+ 0
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ 0
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ 0
 *                                                                  *
+ 0
 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2001             *
+ 0
 * by the XIPHOPHORUS Company http://www.xiph.org/                  *
+ 0

+ 0
 ********************************************************************
+ 0

+ 0
 function: libvorbis codec headers
+ 0
 last mod: $Id: codec.h,v 1.45 2003/09/05 22:34:46 giles Exp $
+ 0

+ 0
 ********************************************************************/
+ 0

+ 0
#define _vorbis_codec_h_
+ 0

+ 0
/********************************************************************
+ 0
 *                                                                  *
+ 0
 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
+ 0
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ 0
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ 0
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ 0
 *                                                                  *
+ 0
 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002             *
+ 0
 * by the Xiph.Org Foundation http://www.xiph.org/                  *
+ 0
 *                                                                  *
+ 0
 ********************************************************************
+ 0

+ 0
 function: toplevel libogg include
+ 0
 last mod: $Id: ogg.h,v 1.19 2002/09/15 23:48:02 xiphmont Exp $
+ 0

+ 0
 ********************************************************************/
+ 0
#define _OGG_H
+ 0

+ 0
/********************************************************************
+ 0
 *                                                                  *
+ 0
 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
+ 0
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ 0
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ 0
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ 0
 *                                                                  *
+ 0
 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002             *
+ 0
 * by the Xiph.Org Foundation http://www.xiph.org/                  *
+ 0
 *                                                                  *
+ 0
 ********************************************************************
+ 0

+ 0
 function: #ifdef jail to whip a few platforms into the UNIX ideal.
+ 0
 last mod: $Id: os_types.h,v 1.14 2003/09/02 05:09:14 xiphmont Exp $
+ 0

+ 0
 ********************************************************************/
+ 0
#define _OS_TYPES_H
+ 0

+ 0
/* make it easy on the folks that want to compile the libs with a
+ 0
   different malloc than stdlib */
+ 0
#define _ogg_malloc  malloc
+ 0
#define _ogg_calloc  calloc
+ 0
#define _ogg_realloc realloc
+ 0
#define _ogg_free    free
+ 0

+ 0
#define __CONFIG_TYPES_H__
+ 0

+ 0
/* these are filled in by configure */
+ 0
typedef int16_t ogg_int16_t;
+ 0
typedef u_int16_t ogg_uint16_t;
+ 0
typedef int32_t ogg_int32_t;
+ 0
typedef u_int32_t ogg_uint32_t;
+ 0
typedef int64_t ogg_int64_t;
+ 0

+ 0
typedef struct {
+ 0
  long endbyte;
+ 0
  int  endbit;
+ 0

+ 0
  unsigned char *buffer;
+ 0
  unsigned char *ptr;
+ 0
  long storage;
+ 0
} oggpack_buffer;
+ 0

+ 0
/* ogg_page is used to encapsulate the data in one Ogg bitstream page *****/
+ 0

+ 0
typedef struct {
+ 0
  unsigned char *header;
+ 0
  long header_len;
+ 0
  unsigned char *body;
+ 0
  long body_len;
+ 0
} ogg_page;
+ 0

+ 0
/* ogg_stream_state contains the current encode/decode state of a logical
+ 0
   Ogg bitstream **********************************************************/
+ 0

+ 0
typedef struct {
+ 0
  unsigned char   *body_data;    /* bytes from packet bodies */
+ 0
  long    body_storage;          /* storage elements allocated */
+ 0
  long    body_fill;             /* elements stored; fill mark */
+ 0
  long    body_returned;         /* elements of fill returned */
+ 0

+ 0

+ 0
  int     *lacing_vals;      /* The values that will go to the segment table */
+ 0
  ogg_int64_t *granule_vals; /* granulepos values for headers. Not compact
+ 0
				this way, but it is simple coupled to the
+ 0
				lacing fifo */
+ 0
  long    lacing_storage;
+ 0
  long    lacing_fill;
+ 0
  long    lacing_packet;
+ 0
  long    lacing_returned;
+ 0

+ 0
  unsigned char    header[282];      /* working space for header encode */
+ 0
  int              header_fill;
+ 0

+ 0
  int     e_o_s;          /* set when we have buffered the last packet in the
+ 0
                             logical bitstream */
+ 0
  int     b_o_s;          /* set after we've written the initial page
+ 0
                             of a logical bitstream */
+ 0
  long    serialno;
+ 0
  long    pageno;
+ 0
  ogg_int64_t  packetno;      /* sequence number for decode; the framing
+ 0
                             knows where there's a hole in the data,
+ 0
                             but we need coupling so that the codec
+ 0
                             (which is in a seperate abstraction
+ 0
                             layer) also knows about the gap */
+ 0
  ogg_int64_t   granulepos;
+ 0

+ 0
} ogg_stream_state;
+ 0

+ 0
/* ogg_packet is used to encapsulate the data and metadata belonging
+ 0
   to a single raw Ogg/Vorbis packet *************************************/
+ 0

+ 0
typedef struct {
+ 0
  unsigned char *packet;
+ 0
  long  bytes;
+ 0
  long  b_o_s;
+ 0
  long  e_o_s;
+ 0

+ 0
  ogg_int64_t  granulepos;
+ 0
  
+ 0
  ogg_int64_t  packetno;     /* sequence number for decode; the framing
+ 0
				knows where there's a hole in the data,
+ 0
				but we need coupling so that the codec
+ 0
				(which is in a seperate abstraction
+ 0
				layer) also knows about the gap */
+ 0
} ogg_packet;
+ 0

+ 0
typedef struct {
+ 0
  unsigned char *data;
+ 0
  int storage;
+ 0
  int fill;
+ 0
  int returned;
+ 0

+ 0
  int unsynced;
+ 0
  int headerbytes;
+ 0
  int bodybytes;
+ 0
} ogg_sync_state;
+ 0

+ 0
/* Ogg BITSTREAM PRIMITIVES: bitstream ************************/
+ 0

+ 0
extern void  oggpack_writeinit(oggpack_buffer *b);
+ 0
extern void  oggpack_writetrunc(oggpack_buffer *b,long bits);
+ 0
extern void  oggpack_writealign(oggpack_buffer *b);
+ 0
extern void  oggpack_writecopy(oggpack_buffer *b,void *source,long bits);
+ 0
extern void  oggpack_reset(oggpack_buffer *b);
+ 0
extern void  oggpack_writeclear(oggpack_buffer *b);
+ 0
extern void  oggpack_readinit(oggpack_buffer *b,unsigned char *buf,int bytes);
+ 0
extern void  oggpack_write(oggpack_buffer *b,unsigned long value,int bits);
+ 0
extern long  oggpack_look(oggpack_buffer *b,int bits);
+ 0
extern long  oggpack_look1(oggpack_buffer *b);
+ 0
extern void  oggpack_adv(oggpack_buffer *b,int bits);
+ 0
extern void  oggpack_adv1(oggpack_buffer *b);
+ 0
extern long  oggpack_read(oggpack_buffer *b,int bits);
+ 0
extern long  oggpack_read1(oggpack_buffer *b);
+ 0
extern long  oggpack_bytes(oggpack_buffer *b);
+ 0
extern long  oggpack_bits(oggpack_buffer *b);
+ 0
extern unsigned char *oggpack_get_buffer(oggpack_buffer *b);
+ 0

+ 0
extern void  oggpackB_writeinit(oggpack_buffer *b);
+ 0
extern void  oggpackB_writetrunc(oggpack_buffer *b,long bits);
+ 0
extern void  oggpackB_writealign(oggpack_buffer *b);
+ 0
extern void  oggpackB_writecopy(oggpack_buffer *b,void *source,long bits);
+ 0
extern void  oggpackB_reset(oggpack_buffer *b);
+ 0
extern void  oggpackB_writeclear(oggpack_buffer *b);
+ 0
extern void  oggpackB_readinit(oggpack_buffer *b,unsigned char *buf,int bytes);
+ 0
extern void  oggpackB_write(oggpack_buffer *b,unsigned long value,int bits);
+ 0
extern long  oggpackB_look(oggpack_buffer *b,int bits);
+ 0
extern long  oggpackB_look1(oggpack_buffer *b);
+ 0
extern void  oggpackB_adv(oggpack_buffer *b,int bits);
+ 0
extern void  oggpackB_adv1(oggpack_buffer *b);
+ 0
extern long  oggpackB_read(oggpack_buffer *b,int bits);
+ 0
extern long  oggpackB_read1(oggpack_buffer *b);
+ 0
extern long  oggpackB_bytes(oggpack_buffer *b);
+ 0
extern long  oggpackB_bits(oggpack_buffer *b);
+ 0
extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b);
+ 0

+ 0
/* Ogg BITSTREAM PRIMITIVES: encoding **************************/
+ 0

+ 0
extern int      ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op);
+ 0
extern int      ogg_stream_pageout(ogg_stream_state *os, ogg_page *og);
+ 0
extern int      ogg_stream_flush(ogg_stream_state *os, ogg_page *og);
+ 0

+ 0
/* Ogg BITSTREAM PRIMITIVES: decoding **************************/
+ 0

+ 0
extern int      ogg_sync_init(ogg_sync_state *oy);
+ 0
extern int      ogg_sync_clear(ogg_sync_state *oy);
+ 0
extern int      ogg_sync_reset(ogg_sync_state *oy);
+ 0
extern int	ogg_sync_destroy(ogg_sync_state *oy);
+ 0

+ 0
extern char    *ogg_sync_buffer(ogg_sync_state *oy, long size);
+ 0
extern int      ogg_sync_wrote(ogg_sync_state *oy, long bytes);
+ 0
extern long     ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og);
+ 0
extern int      ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og);
+ 0
extern int      ogg_stream_pagein(ogg_stream_state *os, ogg_page *og);
+ 0
extern int      ogg_stream_packetout(ogg_stream_state *os,ogg_packet *op);
+ 0
extern int      ogg_stream_packetpeek(ogg_stream_state *os,ogg_packet *op);
+ 0

+ 0
/* Ogg BITSTREAM PRIMITIVES: general ***************************/
+ 0

+ 0
extern int      ogg_stream_init(ogg_stream_state *os,int serialno);
+ 0
extern int      ogg_stream_clear(ogg_stream_state *os);
+ 0
extern int      ogg_stream_reset(ogg_stream_state *os);
+ 0
extern int      ogg_stream_reset_serialno(ogg_stream_state *os,int serialno);
+ 0
extern int      ogg_stream_destroy(ogg_stream_state *os);
+ 0
extern int      ogg_stream_eos(ogg_stream_state *os);
+ 0

+ 0
extern void     ogg_page_checksum_set(ogg_page *og);
+ 0

+ 0
extern int      ogg_page_version(ogg_page *og);
+ 0
extern int      ogg_page_continued(ogg_page *og);
+ 0
extern int      ogg_page_bos(ogg_page *og);
+ 0
extern int      ogg_page_eos(ogg_page *og);
+ 0
extern ogg_int64_t  ogg_page_granulepos(ogg_page *og);
+ 0
extern int      ogg_page_serialno(ogg_page *og);
+ 0
extern long     ogg_page_pageno(ogg_page *og);
+ 0
extern int      ogg_page_packets(ogg_page *og);
+ 0

+ 0
extern void     ogg_packet_clear(ogg_packet *op);
+ 0

+ 0

+ 0
typedef struct vorbis_info{
+ 0
  int version;
+ 0
  int channels;
+ 0
  long rate;
+ 0

+ 0
  /* The below bitrate declarations are *hints*.
+ 0
     Combinations of the three values carry the following implications:
+ 0
     
+ 0
     all three set to the same value: 
+ 0
       implies a fixed rate bitstream
+ 0
     only nominal set: 
+ 0
       implies a VBR stream that averages the nominal bitrate.  No hard 
+ 0
       upper/lower limit
+ 0
     upper and or lower set: 
+ 0
       implies a VBR bitstream that obeys the bitrate limits. nominal 
+ 0
       may also be set to give a nominal rate.
+ 0
     none set:
+ 0
       the coder does not care to speculate.
+ 0
  */
+ 0

+ 0
  long bitrate_upper;
+ 0
  long bitrate_nominal;
+ 0
  long bitrate_lower;
+ 0
  long bitrate_window;
+ 0

+ 0
  void *codec_setup;
+ 0
} vorbis_info;
+ 0

+ 0
/* vorbis_dsp_state buffers the current vorbis audio
+ 0
   analysis/synthesis state.  The DSP state belongs to a specific
+ 0
   logical bitstream ****************************************************/
+ 0
typedef struct vorbis_dsp_state{
+ 0
  int analysisp;
+ 0
  vorbis_info *vi;
+ 0

+ 0
  float **pcm;
+ 0
  float **pcmret;
+ 0
  int      pcm_storage;
+ 0
  int      pcm_current;
+ 0
  int      pcm_returned;
+ 0

+ 0
  int  preextrapolate;
+ 0
  int  eofflag;
+ 0

+ 0
  long lW;
+ 0
  long W;
+ 0
  long nW;
+ 0
  long centerW;
+ 0

+ 0
  ogg_int64_t granulepos;
+ 0
  ogg_int64_t sequence;
+ 0

+ 0
  ogg_int64_t glue_bits;
+ 0
  ogg_int64_t time_bits;
+ 0
  ogg_int64_t floor_bits;
+ 0
  ogg_int64_t res_bits;
+ 0

+ 0
  void       *backend_state;
+ 0
} vorbis_dsp_state;
+ 0

+ 0
typedef struct vorbis_block{
+ 0
  /* necessary stream state for linking to the framing abstraction */
+ 0
  float  **pcm;       /* this is a pointer into local storage */ 
+ 0
  oggpack_buffer opb;
+ 0
  
+ 0
  long  lW;
+ 0
  long  W;
+ 0
  long  nW;
+ 0
  int   pcmend;
+ 0
  int   mode;
+ 0

+ 0
  int         eofflag;
+ 0
  ogg_int64_t granulepos;
+ 0
  ogg_int64_t sequence;
+ 0
  vorbis_dsp_state *vd; /* For read-only access of configuration */
+ 0

+ 0
  /* local storage to avoid remallocing; it's up to the mapping to
+ 0
     structure it */
+ 0
  void               *localstore;
+ 0
  long                localtop;
+ 0
  long                localalloc;
+ 0
  long                totaluse;
+ 0
  struct alloc_chain *reap;
+ 0

+ 0
  /* bitmetrics for the frame */
+ 0
  long glue_bits;
+ 0
  long time_bits;
+ 0
  long floor_bits;
+ 0
  long res_bits;
+ 0

+ 0
  void *internal;
+ 0

+ 0
} vorbis_block;
+ 0

+ 0
/* vorbis_block is a single block of data to be processed as part of
+ 0
the analysis/synthesis stream; it belongs to a specific logical
+ 0
bitstream, but is independant from other vorbis_blocks belonging to
+ 0
that logical bitstream. *************************************************/
+ 0

+ 0
extern void  oggpackB_writeinit(oggpack_buffer *b);
+ 0
extern void  oggpackB_writetrunc(oggpack_buffer *b,long bits);
+ 0
extern void  oggpackB_writealign(oggpack_buffer *b);
+ 0
extern void  oggpackB_writecopy(oggpack_buffer *b,void *source,long bits);
+ 0
extern void  oggpackB_reset(oggpack_buffer *b);
+ 0
extern void  oggpackB_writeclear(oggpack_buffer *b);
+ 0
extern void  oggpackB_readinit(oggpack_buffer *b,unsigned char *buf,int bytes);
+ 0
extern void  oggpackB_write(oggpack_buffer *b,unsigned long value,int bits);
+ 0
extern long  oggpackB_look(oggpack_buffer *b,int bits);
+ 0
extern long  oggpackB_look1(oggpack_buffer *b);
+ 0
extern void  oggpackB_adv(oggpack_buffer *b,int bits);
+ 0
extern void  oggpackB_adv1(oggpack_buffer *b);
+ 0
extern long  oggpackB_read(oggpack_buffer *b,int bits);
+ 0
extern long  oggpackB_read1(oggpack_buffer *b);
+ 0
extern long  oggpackB_bytes(oggpack_buffer *b);
+ 0
extern long  oggpackB_bits(oggpack_buffer *b);
+ 0
extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b);
+ 0

+ 0
struct alloc_chain{
+ 0
  void *ptr;
+ 0
  struct alloc_chain *next;
+ 0
};
+ 0

+ 0
/* vorbis_info contains all the setup information specific to the
+ 0
   specific compression/decompression mode in progress (eg,
+ 0
   psychoacoustic settings, channel setup, options, codebook
+ 0
   etc). vorbis_info and substructures are in backends.h.
+ 0
*********************************************************************/
+ 0

+ 0
/* the comments are not part of vorbis_info so that vorbis_info can be
+ 0
   static storage */
+ 0
typedef struct vorbis_comment{
+ 0
  /* unlimited user comment fields.  libvorbis writes 'libvorbis'
+ 0
     whatever vendor is set to in encode */
+ 0
  char **user_comments;
+ 0
  int   *comment_lengths;
+ 0
  int    comments;
+ 0
  char  *vendor;
+ 0

+ 0
} vorbis_comment;
+ 0

+ 0

+ 0
/* libvorbis encodes in two abstraction layers; first we perform DSP
+ 0
   and produce a packet (see docs/analysis.txt).  The packet is then
+ 0
   coded into a framed OggSquish bitstream by the second layer (see
+ 0
   docs/framing.txt).  Decode is the reverse process; we sync/frame
+ 0
   the bitstream and extract individual packets, then decode the
+ 0
   packet back into PCM audio.
+ 0

+ 0
   The extra framing/packetizing is used in streaming formats, such as
+ 0
   files.  Over the net (such as with UDP), the framing and
+ 0
   packetization aren't necessary as they're provided by the transport
+ 0
   and the streaming layer is not used */
+ 0

+ 0
/* Vorbis PRIMITIVES: general ***************************************/
+ 0

+ 0
intern void     vorbis_info_init(vorbis_info *vi);
+ 0
extern void     vorbis_info_clear(vorbis_info *vi);
+ 0
extern int      vorbis_info_blocksize(vorbis_info *vi,int zo);
+ 0
extern void     vorbis_comment_init(vorbis_comment *vc);
+ 0
extern void     vorbis_comment_add(vorbis_comment *vc, char *comment); 
+ 0
extern void     vorbis_comment_add_tag(vorbis_comment *vc, 
+ 0
				       char *tag, char *contents);
+ 0
extern char    *vorbis_comment_query(vorbis_comment *vc, char *tag, int count);
+ 0
extern int      vorbis_comment_query_count(vorbis_comment *vc, char *tag);
+ 0
extern void     vorbis_comment_clear(vorbis_comment *vc);
+ 0

+ 0
extern int      vorbis_block_init(vorbis_dsp_state *v, vorbis_block *vb);
+ 0
extern int      vorbis_block_clear(vorbis_block *vb);
+ 0
extern void     vorbis_dsp_clear(vorbis_dsp_state *v);
+ 0
extern double   vorbis_granule_time(vorbis_dsp_state *v,
+ 0
				    ogg_int64_t granulepos);
+ 0

+ 0
/* Vorbis PRIMITIVES: analysis/DSP layer ****************************/
+ 0

+ 0
extern int      vorbis_analysis_init(vorbis_dsp_state *v,vorbis_info *vi);
+ 0
extern int      vorbis_commentheader_out(vorbis_comment *vc, ogg_packet *op);
+ 0
extern int      vorbis_analysis_headerout(vorbis_dsp_state *v,
+ 0
					  vorbis_comment *vc,
+ 0
					  ogg_packet *op,
+ 0
					  ogg_packet *op_comm,
+ 0
					  ogg_packet *op_code);
+ 0
extern float  **vorbis_analysis_buffer(vorbis_dsp_state *v,int vals);
+ 0
extern int      vorbis_analysis_wrote(vorbis_dsp_state *v,int vals);
+ 0
extern int      vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb);
+ 0
extern int      vorbis_analysis(vorbis_block *vb,ogg_packet *op);
+ 0

+ 0
extern int      vorbis_bitrate_addblock(vorbis_block *vb);
+ 0
extern int      vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,
+ 0
					   ogg_packet *op);
+ 0

+ 0
/* Vorbis PRIMITIVES: synthesis layer *******************************/
+ 0
extern int      vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,
+ 0
					  ogg_packet *op);
+ 0

+ 0
extern int      vorbis_synthesis_init(vorbis_dsp_state *v,vorbis_info *vi);
+ 0
extern int      vorbis_synthesis_restart(vorbis_dsp_state *v);
+ 0
extern int      vorbis_synthesis(vorbis_block *vb,ogg_packet *op);
+ 0
extern int      vorbis_synthesis_trackonly(vorbis_block *vb,ogg_packet *op);
+ 0
extern int      vorbis_synthesis_blockin(vorbis_dsp_state *v,vorbis_block *vb);
+ 0
extern int      vorbis_synthesis_pcmout(vorbis_dsp_state *v,float ***pcm);
+ 0
extern int      vorbis_synthesis_lapout(vorbis_dsp_state *v,float ***pcm);
+ 0
extern int      vorbis_synthesis_read(vorbis_dsp_state *v,int samples);
+ 0
extern long     vorbis_packet_blocksize(vorbis_info *vi,ogg_packet *op);
+ 0

+ 0
extern int      vorbis_synthesis_halfrate(vorbis_info *v,int flag);
+ 0
extern int      vorbis_synthesis_halfrate_p(vorbis_info *v);
+ 0

+ 0
/* Vorbis ERRORS and return codes ***********************************/
+ 0

+ 0
#define OV_FALSE      -1  
+ 0
#define OV_EOF        -2
+ 0
#define OV_HOLE       -3
+ 0

+ 0
#define OV_EREAD      -128
+ 0
#define OV_EFAULT     -129
+ 0
#define OV_EIMPL      -130
+ 0
#define OV_EINVAL     -131
+ 0
#define OV_ENOTVORBIS -132
+ 0
#define OV_EBADHEADER -133
+ 0
#define OV_EVERSION   -134
+ 0
#define OV_ENOTAUDIO  -135
+ 0
#define OV_EBADPACKET -136
+ 0
#define OV_EBADLINK   -137
+ 0
#def OV_ENOSEEK    -138
+ 0

+ 0
typedef void TIMER;
+ 0
typedef long (*audio_read_func)(void *src, float **buffer, int samples);
+ 0
typedef void (*progress_func)(char *fn, long totalsamples, 
+ 0
		long samples, double time);
+ 0
typedef void (*enc_end_func)(char *fn, double time, int rate, 
+ 0
		long samples, long bytes);
+ 0
typedef void (*enc_start_func)(char *fn, char *outfn, int bitrate, 
+ 0
        float quality, int qset, int managed, int min_br, int max_br);
+ 0
typedef void (*error_func)(char *errormessage);
+ 0

+ 0

+ 0
void *timer_start(void);
+ 0
double timer_time(void *);
+ 0
void timer_clear(void *);
+ 0
int create_directories(char *);
+ 0

+ 0
void update_statistics_full(char *fn, long total, long done, double time);
+ 0
void update_statistics_notime(char *fn, long total, long done, double time);
+ 0
void update_statistics_null(char *fn, long total, long done, double time);
+ 0
void start_encode_full(char *fn, char *outfn, int bitrate, float quality, int qset,
+ 0
        int managed, int min, int max);
+ 0
void start_encode_null(char *fn, char *outfn, int bitrate, float quality, int qset,
+ 0
        int managed, int min, int max);
+ 0
void final_statistics(char *fn, double time, int rate, long total_samples,
+ 0
		long bytes);
+ 0
void final_statistics_null(char *fn, double time, int rate, long total_samples,
+ 0
		long bytes);
+ 0
void encode_error(char *errmsg);
+ 0

+ 0
typedef struct {
+ 0
    char *arg;
+ 0
    char *val;
+ 0
} adv_opt;
+ 0

+ 0
typedef struct
+ 0
{
+ 0
	char **title;
+ 0
	int title_count;
+ 0
	char **artist;
+ 0
	int artist_count;
+ 0
	char **album;
+ 0
	int album_count;
+ 0
	char **comments;
+ 0
	int comment_count;
+ 0
	char **tracknum;
+ 0
	int track_count;
+ 0
	char **dates;
+ 0
	int date_count;
+ 0
	char **genre;
+ 0
	int genre_count;
+ 0
    adv_opt *advopt;
+ 0
    int advopt_count;
+ 0
	int copy_comments;
+ 0

+ 0
	int quiet;
+ 0

+ 0
	int rawmode;
+ 0
	int raw_samplesize;
+ 0
	int raw_samplerate;
+ 0
	int raw_channels;
+ 0
    int raw_endianness;
+ 0

+ 0
	char *namefmt;
+ 0
    char *namefmt_remove;
+ 0
    char *namefmt_replace;
+ 0
	char *outfile;
+ 0

+ 0
	/* All 3 in kbps */
+ 0
    int managed;
+ 0
	int min_bitrate;
+ 0
	int nominal_bitrate;
+ 0
	int max_bitrate;
+ 0

+ 0
	/* Float from 0 to 1 (low->high) */
+ 0
	float quality;
+ 0
    int quality_set;
+ 0

+ 0
    int resamplefreq;
+ 0
    int downmix;
+ 0
    float scale;
+ 0

+ 0
	unsigned int serial;
+ 0
} oe_options;
+ 0

+ 0
typedef struct
+ 0
{
+ 0
	vorbis_comment *comments;
+ 0
	unsigned int serialno;
+ 0

+ 0
	audio_read_func read_samples;
+ 0
	progress_func progress_update;
+ 0
	enc_end_func end_encode;
+ 0
	enc_start_func start_encode;
+ 0
	error_func error;
+ 0
	
+ 0
	void *readdata;
+ 0

+ 0
	long total_samples_per_channel;
+ 0
	int channels;
+ 0
	long rate;
+ 0
	int samplesize;
+ 0
    int endianness;
+ 0
    int resamplefreq;
+ 0
	int copy_comments;
+ 0

+ 0
	/* Various bitrate/quality options */
+ 0
    int managed;
+ 0
	int bitrate;
+ 0
	int min_bitrate;
+ 0
	int max_bitrate;
+ 0
	float quality;
+ 0
    int quality_set;
+ 0
    adv_opt *advopt;
+ 0
    int advopt_count;
+ 0

+ 0
	FILE *out;
+ 0
	char *filename;
+ 0
	char *infilename;
+ 0
} oe_enc_opt;
+ 0

+ 0

+ 0
int oe_encode(oe_enc_opt *opt);
+ 0

+ 0
#define __AUDIO_H
+ 0

+ 0
int setup_resample(oe_enc_opt *opt);
+ 0
void clear_resample(oe_enc_opt *opt);
+ 0
void setup_downmix(oe_enc_opt *opt);
+ 0
void clear_downmix(oe_enc_opt *opt);
+ 0
void setup_scaler(oe_enc_opt *opt, float scale);
+ 0
void clear_scaler(oe_enc_opt *opt);
+ 0

+ 0
typedef struct
+ 0
{
+ 0
	int (*id_func)(unsigned char *buf, int len); /* Returns true if can load file */
+ 0
	int id_data_len; /* Amount of data needed to id whether this can load the file */
+ 0
	int (*open_func)(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen);
+ 0
	void (*close_func)(void *);
+ 0
	char *format;
+ 0
	char *description;
+ 0
} input_format;
+ 0

+ 0

+ 0
typedef struct {
+ 0
	short format;
+ 0
	short channels;
+ 0
	int samplerate;
+ 0
	int bytespersec;
+ 0
	short align;
+ 0
	short samplesize;
+ 0
} wav_fmt;
+ 0

+ 0
typedef struct {
+ 0
	short channels;
+ 0
	short samplesize;
+ 0
	long totalsamples;
+ 0
	long samplesread;
+ 0
	FILE *f;
+ 0
	short bigendian;
+ 0
} wavfile;
+ 0

+ 0
typedef struct {
+ 0
	short channels;
+ 0
	int totalframes;
+ 0
	short samplesize;
+ 0
	int rate;
+ 0
	int offset;
+ 0
	int blocksize;
+ 0
} aiff_fmt;
+ 0

+ 0
typedef wavfile aifffile; /* They're the same */
+ 0

+ 0
input_format *open_audio_file(FILE *in, oe_enc_opt *opt);
+ 0

+ 0
int raw_open(FILE *in, oe_enc_opt *opt);
+ 0
int wav_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen);
+ 0
int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen);
+ 0
int wav_id(unsigned char *buf, int len);
+ 0
int aiff_id(unsigned char *buf, int len);
+ 0
void wav_close(void *);
+ 0
void raw_close(void *);
+ 0

+ 0
long wav_read(void *, float **buffer, int samples);
+ 0
long wav_ieee_read(void *, float **buffer, int samples);
+ 0
long raw_read_stereo(void *, float **buffer, int samples);
+ 0

+ 0
#define _(X) (X)
+ 0
#define textdomain(X)
+ 0
#define bindtextdomain(X, Y)
+ 0
#define N_(X) (X)
+ 0

+ 0

+ 0
#define VERSION_STRING "OggEnc v1.0.1 (libvorbis 1.0.1)\n"
+ 0
#define COPYRIGHT "(c) 2000-2003 Michael Smith <msmith@xiph.org>\n"
+ 0

+ 0
#define CHUNK 4096 /* We do reads, etc. in multiples of this */
+ 0

+ 0
struct option long_options[] = {
+ 0
	{"quiet",0,0,'Q'},
+ 0
	{"help",0,0,'h'},
+ 0
	{"comment",1,0,'c'},
+ 0
	{"artist",1,0,'a'},
+ 0
	{"album",1,0,'l'},
+ 0
	{"title",1,0,'t'},
+ 0
    {"genre",1,0,'G'},
+ 0
	{"names",1,0,'n'},
+ 0
    {"name-remove",1,0,'X'},
+ 0
    {"name-replace",1,0,'P'},
+ 0
	{"output",1,0,'o'},
+ 0
	{"version",0,0,'v'},
+ 0
	{"raw",0,0,'r'},
+ 0
	{"raw-bits",1,0,'B'},
+ 0
	{"raw-chan",1,0,'C'},
+ 0
	{"raw-rate",1,0,'R'},
+ 0
    {"raw-endianness",1,0, 0},
+ 0
	{"bitrate",1,0,'b'},
+ 0
	{"min-bitrate",1,0,'m'},
+ 0
	{"max-bitrate",1,0,'M'},
+ 0
	{"quality",1,0,'q'},
+ 0
	{"date",1,0,'d'},
+ 0
	{"tracknum",1,0,'N'},
+ 0
	{"serial",1,0,'s'},
+ 0
    {"managed", 0, 0, 0},
+ 0
    {"resample",1,0,0},
+ 0
    {"downmix", 0,0,0},
+ 0
    {"scale", 1, 0, 0}, 
+ 0
    {"advanced-encode-option", 1, 0, 0},
+ 0
	{"discard-comments", 0, 0, 0},
+ 0
	{NULL,0,0,0}
+ 0
};
+ 0
	
+ 0
static char *generate_name_string(char *format, char *remove_list, 
+ 0
        char *replace_list, char *artist, char *title, char *album, 
+ 0
        char *track, char *date, char *genre);
+ 0
static void parse_options(int argc, char **argv, oe_options *opt);
+ 0
static void build_comments(vorbis_comment *vc, oe_options *opt, int filenum, 
+ 0
		char **artist,char **album, char **title, char **tracknum, char **date,
+ 0
        char **genre);
+ 0
static void usage(void);
+ 0

+ 0
int main(int argc, char **argv)
+ 0
{
+ 0
	/* Default values */
+ 0
	oe_options opt = {NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 
+ 0
			  0, NULL, 0, NULL, 0, NULL, 0, 1, 0, 0,16,44100,2, 0, NULL,
+ 0
			  DEFAULT_NAMEFMT_REMOVE, DEFAULT_NAMEFMT_REPLACE, 
+ 0
			  NULL, 0, -1,-1,-1,.3,-1,0, 0,0.f, 0}; 
+ 0

+ 0
	int i;
+ 0

+ 0
	char **infiles;
+ 0
	int numfiles;
+ 0
	int errors=0;
+ 0

+ 0
	parse_options(argc, argv, &opt);
+ 0

+ 0
	if(optind >= argc)
+ 0
	{
+ 0
		fprintf(stderr, _("%s%s\nERROR: No input files specified. Use -h for help.\n"), VERSION_STRING, COPYRIGHT);
+ 0
		return 1;
+ 0
	}
+ 0
	else
+ 0
	{
+ 0
		infiles = argv + optind;
+ 0
		numfiles = argc - optind;
+ 0
	}
+ 0

+ 0
	/* Now, do some checking for illegal argument combinations */
+ 0

+ 0
	for(i = 0; i < numfiles; i++)
+ 0
	{
+ 0
		if(!strcmp(infiles[i], "-") && numfiles > 1)
+ 0
		{
+ 0
			fprintf(stderr, _("ERROR: Multiple files specified when using stdin\n"));
+ 0
			exit(1);
+ 0
		}
+ 0
	}
+ 0

+ 0
	if(numfiles > 1 && opt.outfile)
+ 0
	{
+ 0
		fprintf(stderr, _("ERROR: Multiple input files with specified output filename: suggest using -n\n"));
+ 0
		exit(1);
+ 0
	}
+ 0

+ 0
	if(opt.serial == 0)
+ 0
	{
+ 0
		/* We randomly pick a serial number. This is then incremented for each file */
+ 0
		srand(time(NULL));
+ 0
		opt.serial = rand();
+ 0
	}
+ 0

+ 0
	for(i = 0; i < numfiles; i++)
+ 0
	{
+ 0
		/* Once through the loop for each file */
+ 0

+ 0
		oe_enc_opt      enc_opts;
+ 0
		vorbis_comment  vc;
+ 0
		char *out_fn = NULL;
+ 0
		FILE *in, *out = NULL;
+ 0
		int foundformat = 0;
+ 0
		int closeout = 0, closein = 0;
+ 0
		char *artist=NULL, *album=NULL, *title=NULL, *track=NULL;
+ 0
        char *date=NULL, *genre=NULL;
+ 0
		input_format *format;
+ 0

+ 0
		/* Set various encoding defaults */
+ 0

+ 0
		enc_opts.serialno = opt.serial++;
+ 0
		enc_opts.progress_update = update_statistics_full;
+ 0
        enc_opts.start_encode = start_encode_full;
+ 0
		enc_opts.end_encode = final_statistics;
+ 0
		enc_opts.error = encode_error;
+ 0
		enc_opts.comments = &vc;
+ 0
		enc_opts.copy_comments = opt.copy_comments;
+ 0

+ 0
		/* OK, let's build the vorbis_comments structure */
+ 0
		build_comments(&vc, &opt, i, &artist, &album, &title, &track, 
+ 0
                &date, &genre);
+ 0

+ 0
		if(!strcmp(infiles[i], "-"))
+ 0
		{
+ 0
			setbinmode(stdin);
+ 0
			in = stdin;
+ 0
            infiles[i] = NULL;
+ 0
			if(!opt.outfile)
+ 0
			{
+ 0
				setbinmode(stdout);
+ 0
				out = stdout;
+ 0
			}
+ 0
		}
+ 0
		else
+ 0
		{
+ 0
			in = fopen(infiles[i], "rb");
+ 0

+ 0
			if(in == NULL)
+ 0
			{
+ 0
				fprintf(stderr, _("ERROR: Cannot open input file \"%s\": %s\n"), infiles[i], strerror(errno));
+ 0
				free(out_fn);
+ 0
				errors++;
+ 0
				continue;
+ 0
			}
+ 0

+ 0
			closein = 1;
+ 0
		}
+ 0

+ 0
		/* Now, we need to select an input audio format - we do this before opening
+ 0
		   the output file so that we don't end up with a 0-byte file if the input
+ 0
		   file can't be read */
+ 0

+ 0
		if(opt.rawmode)
+ 0
		{
+ 0
			enc_opts.rate=opt.raw_samplerate;
+ 0
			enc_opts.channels=opt.raw_channels;
+ 0
			enc_opts.samplesize=opt.raw_samplesize;
+ 0
            enc_opts.endianness=opt.raw_endianness;
+ 0
			raw_open(in, &enc_opts);
+ 0
			foundformat=1;
+ 0
		}
+ 0
		else
+ 0
		{
+ 0
			format = open_audio_file(in, &enc_opts);
+ 0
			if(format)
+ 0
			{
+ 0
                if(!opt.quiet)
+ 0
				    fprintf(stderr, _("Opening with %s module: %s\n"), 
+ 0
					    	format->format, format->description);
+ 0
				foundformat=1;
+ 0
			}
+ 0

+ 0
		}
+ 0

+ 0
		if(!foundformat)
+ 0
		{
+ 0
			fprintf(stderr, _("ERROR: Input file \"%s\" is not a supported format\n"), infiles[i]?infiles[i]:"(stdin)");
+ 0
    		if(closein)
+ 0
				fclose(in);
+ 0
			errors++;
+ 0
			continue;
+ 0
		}
+ 0

+ 0
		/* Ok. We can read the file - so now open the output file */
+ 0

+ 0
		if(opt.outfile && !strcmp(opt.outfile, "-"))
+ 0
		{
+ 0
			setbinmode(stdout);
+ 0
			out = stdout;
+ 0
		}
+ 0
		else if(out == NULL)
+ 0
		{
+ 0
			if(opt.outfile)
+ 0
			{
+ 0
				out_fn = strdup(opt.outfile);
+ 0
			}
+ 0
			else if(opt.namefmt)
+ 0
			{
+ 0
				out_fn = generate_name_string(opt.namefmt, opt.namefmt_remove, 
+ 0
                        opt.namefmt_replace, artist, title, album, track,date,
+ 0
                        genre);
+ 0
			}
+ 0
            /* This bit was widely derided in mid-2002, so it's been removed */
+ 0
            /*
+ 0
			else if(opt.title)
+ 0
			{
+ 0
				out_fn = malloc(strlen(title) + 5);
+ 0
				strcpy(out_fn, title);
+ 0
				strcat(out_fn, ".ogg");
+ 0
			}
+ 0
            */
+ 0
			else if(infiles[i])
+ 0
			{
+ 0
				/* Create a filename from existing filename, replacing extension with .ogg */
+ 0
				char *start, *end;
+ 0

+ 0
				start = infiles[i];
+ 0
				end = strrchr(infiles[i], '.');
+ 0
				end = end?end:(start + strlen(infiles[i])+1);
+ 0
			
+ 0
				out_fn = malloc(end - start + 5);
+ 0
				strncpy(out_fn, start, end-start);
+ 0
				out_fn[end-start] = 0;
+ 0
				strcat(out_fn, ".ogg");
+ 0
			}
+ 0
            else {
+ 0
                fprintf(stderr, _("WARNING: No filename, defaulting to \"default.ogg\"\n"));
+ 0
                out_fn = strdup("default.ogg");
+ 0
            }
+ 0

+ 0
            /* Create any missing subdirectories, if possible */
+ 0
            if(create_directories(out_fn)) {
+ 0
                if(closein)
+ 0
                    fclose(in);
+ 0
				fprintf(stderr, _("ERROR: Could not create required subdirectories for output filename \"%s\"\n"), out_fn);
+ 0
				errors++;
+ 0
				free(out_fn);
+ 0
				continue;
+ 0
            }
+ 0

+ 0
			out = fopen(out_fn, "wb");
+ 0
			if(out == NULL)
+ 0
			{
+ 0
				if(closein)
+ 0
					fclose(in);
+ 0
				fprintf(stderr, _("ERROR: Cannot open output file \"%s\": %s\n"), out_fn, strerror(errno));
+ 0
				errors++;
+ 0
				free(out_fn);
+ 0
				continue;
+ 0
			}	
+ 0
			closeout = 1;
+ 0
		}
+ 0

+ 0
		/* Now, set the rest of the options */
+ 0
		enc_opts.out = out;
+ 0
		enc_opts.comments = &vc;
+ 0
		enc_opts.filename = out_fn;
+ 0
		enc_opts.infilename = infiles[i];
+ 0
        enc_opts.managed = opt.managed;
+ 0
		enc_opts.bitrate = opt.nominal_bitrate; 
+ 0
		enc_opts.min_bitrate = opt.min_bitrate;
+ 0
		enc_opts.max_bitrate = opt.max_bitrate;
+ 0
		enc_opts.quality = opt.quality;
+ 0
		enc_opts.quality_set = opt.quality_set;
+ 0
        enc_opts.advopt = opt.advopt;
+ 0
        enc_opts.advopt_count = opt.advopt_count;
+ 0

+ 0
        if(opt.resamplefreq && opt.resamplefreq != enc_opts.rate) {
+ 0
            int fromrate = enc_opts.rate;
+ 0
            enc_opts.resamplefreq = opt.resamplefreq;
+ 0
            if(setup_resample(&enc_opts)) {
+ 0
                errors++;
+ 0
                goto clear_all;
+ 0
            }
+ 0
            else if(!opt.quiet)
+ 0
                fprintf(stderr, _("Resampling input from %d Hz to %d Hz\n"), fromrate, opt.resamplefreq);
+ 0
        }
+ 0

+ 0
        if(opt.downmix) {
+ 0
            if(enc_opts.channels == 2) {
+ 0
                setup_downmix(&enc_opts);
+ 0
                if(!opt.quiet)
+ 0
                    fprintf(stderr, _("Downmixing stereo to mono\n"));
+ 0
            }
+ 0
            else {
+ 0
                fprintf(stderr, _("ERROR: Can't downmix except from stereo to mono\n"));
+ 0
                errors++;
+ 0
                if(opt.resamplefreq && opt.resamplefreq != enc_opts.rate)
+ 0
                    clear_resample(&enc_opts);
+ 0
                goto clear_all;
+ 0
            }
+ 0
        }
+ 0

+ 0
        if(opt.scale > 0.f) {
+ 0
            setup_scaler(&enc_opts, opt.scale);
+ 0
            if(!opt.quiet)
+ 0
                fprintf(stderr, _("Scaling input to %f\n"), opt.scale);
+ 0
        }
+ 0

+ 0

+ 0
		if(!enc_opts.total_samples_per_channel)
+ 0
			enc_opts.progress_update = update_statistics_notime;
+ 0

+ 0
		if(opt.quiet)
+ 0
		{
+ 0
            enc_opts.start_encode = start_encode_null;
+ 0
			enc_opts.progress_update = update_statistics_null;
+ 0
			enc_opts.end_encode = final_statistics_null;
+ 0
		}
+ 0

+ 0
		if(oe_encode(&enc_opts))
+ 0
			errors++;
+ 0

+ 0
        if(opt.scale > 0)
+ 0
            clear_scaler(&enc_opts);
+ 0
        if(opt.downmix)
+ 0
            clear_downmix(&enc_opts);
+ 0
        if(opt.resamplefreq && opt.resamplefreq != enc_opts.rate)
+ 0
            clear_resample(&enc_opts);
+ 0
clear_all:
+ 0

+ 0
		if(out_fn) free(out_fn);
+ 0
        if(opt.outfile) free(opt.outfile);
+ 0
		vorbis_comment_clear(&vc);
+ 0
		if(!opt.rawmode) 
+ 0
			format->close_func(enc_opts.readdata);
+ 0

+ 0
		if(closein)
+ 0
			fclose(in);
+ 0
		if(closeout)
+ 0
			fclose(out);
+ 0
	}/* Finished this file, loop around to next... */
+ 0

+ 0
	return errors?1:0;
+ 0

+ 0
}
+ 0

+ 0
static void usage(void)
+ 0
{
+ 0
	fprintf(stdout, 
+ 0
		_("%s%s\n"
+ 0
		"Usage: oggenc [options] input.wav [...]\n"
+ 0
		"\n"
+ 0
		"OPTIONS:\n"
+ 0
		" General:\n"
+ 0
		" -Q, --quiet          Produce no output to stderr\n"
+ 0
		" -h, --help           Print this help text\n"
+ 0
		" -r, --raw            Raw mode. Input files are read directly as PCM data\n"
+ 0
		" -B, --raw-bits=n     Set bits/sample for raw input. Default is 16\n"
+ 0
		" -C, --raw-chan=n     Set number of channels for raw input. Default is 2\n"
+ 0
		" -R, --raw-rate=n     Set samples/sec for raw input. Default is 44100\n"
+ 0
        " --raw-endianness     1 for bigendian, 0 for little (defaults to 0)\n"
+ 0
		" -b, --bitrate        Choose a nominal bitrate to encode at. Attempt\n"
+ 0
		"                      to encode at a bitrate averaging this. Takes an\n"
+ 0
		"                      argument in kbps. This uses the bitrate management\n"
+ 0
        "                      engine, and is not recommended for most users.\n"
+ 0
        "                      See -q, --quality for a better alternative.\n"
+ 0
		" -m, --min-bitrate    Specify a minimum bitrate (in kbps). Useful for\n"
+ 0
		"                      encoding for a fixed-size channel.\n"
+ 0
		" -M, --max-bitrate    Specify a maximum bitrate in kbps. Useful for\n"
+ 0
		"                      streaming applications.\n"
+ 0
		" -q, --quality        Specify quality between 0 (low) and 10 (high),\n"
+ 0
		"                      instead of specifying a particular bitrate.\n"
+ 0
		"                      This is the normal mode of operation.\n"
+ 0
        "                      Fractional qualities (e.g. 2.75) are permitted\n"
+ 0
        "                      Quality -1 is also possible, but may not be of\n"
+ 0
        "                      acceptable quality.\n"
+ 0
        " --resample n         Resample input data to sampling rate n (Hz)\n"
+ 0
        " --downmix            Downmix stereo to mono. Only allowed on stereo\n"
+ 0
        "                      input.\n"
+ 0
		"                      multiple files, this will be incremented for each\n"
+ 0
		" -c, --comment=c      Add the given string as an extra comment. This may be\n"
+ 0
		"                      used multiple times. The argument should be in the\n"
+ 0
        "                      format \"tag=value\".\n"
+ 0
		" -d, --date           Date for track (usually date of performance)\n"
+ 0
		" -N, --tracknum       Track number for this track\n"
+ 0
		" -t, --title          Title for this track\n"
+ 0
		" -l, --album          Name of album\n"
+ 0
		" -a, --artist         Name of artist\n"
+ 0
        " -G, --genre          Genre of track\n"
+ 0
                      stream after the first.\n"
+ 0
		" --discard-comments   Prevents comments in FLAC and Ogg FLAC files from\n"
+ 0
		"                      being copied to the output Ogg Vorbis file.\n"
+ 0
		"\n"
+ 0
		" Naming:\n"
+ 0
		" -o, --output=fn      Write file to fn (only valid in single-file mode)\n"
+ 0
		" -n, --names=string   Produce filenames as this string, with %%a, %%t, %%l,\n"
+ 0
		"                      %%n, %%d replaced by artist, title, album, track number,\n"
+ 0
		"                      and date, respectively (see below for specifying these).\n"
+ 0
		"                      %%%% gives a literal %%.\n"
+ 0
        " -X, --name-remove=s  Remove the specified characters from parameters to the\n"
+ 0
        "                      -n format string. Useful to ensure legal filenames.\n"
+ 0
        " -P, --name-replace=s Replace characters removed by --name-remove with the\n"
+ 0
        "                      characters specified. If this string is shorter than the\n"
+ 0
        "                      --name-remove list or is not specified, the extra\n"
+ 0
        "                      characters are just removed.\n"
+ 0
        "                      Default settings for the above two arguments are platform\n"
+ 0
        "                      specific.\n"
+ 0
		" -c, --comment=c      Add the given string as an extra comment. This may be\n"
+ 0
		"                      used multiple times. The argument should be in the\n"
+ 0
        "                      format \"tag=value\".\n"
+ 0
		" -d, --date           Date for track (usually date of performance)\n"
+ 0
		" -N, --tracknum       Track number for this track\n"
+ 0
		" -t, --title          Title for this track\n"
+ 0
		" -l, --album          Name of album\n"
+ 0
		" -a, --artist         Name of artist\n"
+ 0
        " -G, --genre          Genre of track\n"
+ 0
		"                      If multiple input files are given, then multiple\n"
+ 0
		"                      instances of the previous five arguments will be used,\n"
+ 0
		"                      in the order they are given. If fewer titles are\n"
+ 0
		"                      specified than files, OggEnc will print a warning, and\n"
+ 0
		"                      reuse the final one for the remaining files. If fewer\n"
+ 0
		"                      track numbers are given, the remaining files will be\n"
+ 0
		"                      unnumbered. For the others, the final tag will be reused\n"
+ 0
		"                      for all others without warning (so you can specify a date\n"
+ 0
		"                      once, for example, and have it used for all the files)\n"
+ 0
		"\n"
+ 0
		"INPUT FILES:\n"
+ 0
		" OggEnc input files must currently be 24, 16, or 8 bit PCM WAV, AIFF, or AIFF/C\n"
+ 0
		" files, 32 bit IEEE floating point WAV, and optionally FLAC or Ogg FLAC. Files\n"
+ 0
                "  may be mono or stereo (or more channels) and any sample rate.\n"
+ 0
		" Alternatively, the --raw option may be used to use a raw PCM data file, which\n"
+ 0
		" must be 16 bit stereo little-endian PCM ('headerless wav'), unless additional\n"
+ 0
		" parameters for raw mode are specified.\n"
+ 0
		" You can specify taking the file from stdin by using - as the input filename.\n"
+ 0
		" In this mode, output is to stdout unless an output filename is specified\n"
+ 0
		" with -o\n"
+ 0
		"\n"), VERSION_STRING, COPYRIGHT);
+ 0
}
+ 0

+ 0
static int strncpy_filtered(char *dst, char *src, int len, char *remove_list, 
+ 0
        char *replace_list)
+ 0
{
+ 0
    char *hit, *drop_margin;
+ 0
    int used=0;
+ 0

+ 0
    if(remove_list == NULL || *remove_list == 0)
+ 0
    {
+ 0
        strncpy(dst, src, len-1);
+ 0
        dst[len-1] = 0;
+ 0
        return strlen(dst);
+ 0
    }
+ 0

+ 0
    drop_margin = remove_list + (replace_list == NULL?0:strlen(replace_list));
+ 0

+ 0
    while(*src && used < len-1)
+ 0
    {
+ 0
        if((hit = strchr(remove_list, *src)) != NULL)
+ 0
        {
+ 0
            if(hit < drop_margin)
+ 0
            {
+ 0
                *dst++ = replace_list[hit - remove_list];
+ 0
                used++;
+ 0
            }
+ 0
        }
+ 0
        else
+ 0
        {
+ 0
            *dst++ = *src;
+ 0
            used++;
+ 0
        }
+ 0
        src++;
+ 0
    }
+ 0
    *dst = 0;
+ 0

+ 0
    return used;
+ 0
}
+ 0

+ 0
static char *generate_name_string(char *format, char *remove_list,
+ 0
        char *replace_list, char *artist, char *title, char *album, 
+ 0
        char *track, char *date, char *genre)
+ 0
{
+ 0
	char *buffer;
+ 0
	char next;
+ 0
	char *string;
+ 0
	int used=0;
+ 0
	int buflen;
+ 0

+ 0
		buffer = calloc(CHUNK+1,1);
+ 0
		buflen = CHUNK;
+ 0

+ 0
	while(*format && used < buflen)
+ 0
	{
+ 0
		next = *format++;
+ 0

+ 0
		if(next == '%')
+ 0
		{
+ 0
			switch(*format++)
+ 0
			{
+ 0
				case '%':
+ 0
					*(buffer+(used++)) = '%';
+ 0
					break;
+ 0
				case 'a':
+ 0
					string = artist?artist:_("(none)");
+ 0
					used += strncpy_filtered(buffer+used, string, buflen-used, 
+ 0
                            remove_list, replace_list);
+ 0
					break;
+ 0
				case 'd':
+ 0
					string = date?date:_("(none)");
+ 0
					used += strncpy_filtered(buffer+used, string, buflen-used,
+ 0
                            remove_list, replace_list);
+ 0
					break;
+ 0
                case 'g':
+ 0
                    string = genre?genre:_("(none)");
+ 0
                    used += strncpy_filtered(buffer+used, string, buflen-used,
+ 0
                            remove_list, replace_list);
+ 0
                    break;
+ 0
				case 't':
+ 0
					string = title?title:_("(none)");
+ 0
					used += strncpy_filtered(buffer+used, string, buflen-used,
+ 0
                            remove_list, replace_list);
+ 0
					break;
+ 0
				case 'l':
+ 0
					string = album?album:_("(none)");
+ 0
					used += strncpy_filtered(buffer+used, string, buflen-used,
+ 0
                            remove_list, replace_list);
+ 0
					break;
+ 0
				case 'n':
+ 0
					string = track?track:_("(none)");
+ 0
					used += strncpy_filtered(buffer+used, string, buflen-used,
+ 0
                            remove_list, replace_list);
+ 0
					break;
+ 0
				default:
+ 0
					fprintf(stderr, _("WARNING: Ignoring illegal escape character '%c' in name format\n"), *(format - 1));
+ 0
					break;
+ 0
			}
+ 0
		}
+ 0
		else
+ 0
			*(buffer + (used++)) = next;
+ 0
	}
+ 0

+ 0
	return buffer;
+ 0
}
+ 0

+ 0
static void parse_options(int argc, char **argv, oe_options *opt)
+ 0
{
+ 0
	int ret;
+ 0
	int option_index = 1;
+ 0

+ 0
	while((ret = getopt_long(argc, argv, "A:a:b:B:c:C:d:G:hl:m:M:n:N:o:P:q:QrR:s:t:vX:", 
+ 0
					long_options, &option_index)) != -1)
+ 0
	{
+ 0
		switch(ret)
+ 0
		{
+ 0
			case 0:
+ 0
                if(!strcmp(long_options[option_index].name, "managed")) {
+ 0
		            if(!opt->managed){
+ 0
                        if(!opt->quiet)
+ 0
            		        fprintf(stderr, 
+ 0
                                    _("Enabling bitrate management engine\n"));
+ 0
                        opt->manage = 1;
+ 0
        		    }
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name, 
+ 0
                            "raw-endianness")) {
+ 0
				    if (opt->rawmode != 1)
+ 0
    				{
+ 0
	    				opt->rawmode = 1;
+ 0
		    			fprintf(stderr, _("WARNING: Raw endianness specified for non-raw data. Assuming input is raw.\n"));
+ 0
			    	}
+ 0
				    if(sscanf(optarg, "%d", &opt->raw_endianness) != 1) {
+ 0
                        fprintf(stderr, _("WARNING: Couldn't read endianness argument \"%s\"\n"), optarg);
+ 0
    					opt->raw_endianness = 0;
+ 0
                    }
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name,
+ 0
                            "resample")) {
+ 0
				    if(sscanf(optarg, "%d", &opt->resamplefreq) != 1) {
+ 0
                        fprintf(stderr, _("WARNING: Couldn't read resampling frequency \"%s\"\n"), optarg);
+ 0
    					opt->resamplefreq = 0;
+ 0
                    }
+ 0
                    if(opt->resamplefreq < 100) /* User probably specified it
+ 0
                                                   in kHz accidently */
+ 0
                        fprintf(stderr, 
+ 0
                                _("Warning: Resample rate specified as %d Hz. Did you mean %d Hz?\n"), 
+ 0
                                opt->resamplefreq, opt->resamplefreq*1000);
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name, "downmix")) {
+ 0
                    opt->downmix = 1;
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name, "scale")) {
+ 0
                    opt->scale = atof(optarg);
+ 0
				    if(sscanf(optarg, "%f", &opt->scale) != 1) {
+ 0
                        opt->scale = 0;
+ 0
                        fprintf(stderr, _("Warning: Couldn't parse scaling factor \"%s\"\n"), 
+ 0
                                optarg);
+ 0
                    }
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name, "advanced-encode-option")) {
+ 0
                    char *arg = strdup(optarg);
+ 0
                    char *val;
+ 0

+ 0
                    val = strchr(arg, '=');
+ 0
                    if(val == NULL) {
+ 0
                        fprintf(stderr, _("No value for advanced encoder option found\n"));
+ 0
                        continue;
+ 0
                    }
+ 0
                    else
+ 0
                        *val++=0;
+ 0

+ 0
                    opt->advopt = realloc(opt->advopt, (++opt->advopt_count)*sizeof(adv_opt));
+ 0
                    opt->advopt[opt->advopt_count - 1].arg = arg;
+ 0
                    opt->advopt[opt->advopt_count - 1].val = val;
+ 0
                }
+ 0
                else if(!strcmp(long_options[option_index].name, "discard-comments")) {
+ 0
		  opt->copy_comments = 0;
+ 0
		}
+ 0

+ 0
                else {
+ 0
				    fprintf(stderr, _("Internal error parsing command line options\n"));
+ 0
				    exit(1);
+ 0
                }
+ 0

+ 0
				break;
+ 0
			case 'a':
+ 0
				opt->artist = realloc(opt->artist, (++opt->artist_count)*sizeof(char *));
+ 0
				opt->artist[opt->artist_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
			case 'c':
+ 0
                else if(strchr(optarg, '=') == NULL) {
+ 0
                    fprintf(stderr, _("Warning: Illegal comment used (\"%s\"), ignoring.\n"), optarg);
+ 0
                    break;
+ 0
                }
+ 0
				opt->comments = realloc(opt->comments, (++opt->comment_count)*sizeof(char *));
+ 0
				opt->comments[opt->comment_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
			case 'd':
+ 0
				opt->dates = realloc(opt->dates, (++opt->date_count)*sizeof(char *));
+ 0
				opt->dates[opt->date_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
            case 'G':
+ 0
                opt->genre = realloc(opt->genre, (++opt->genre_count)*sizeof(char *));
+ 0
                opt->genre[opt->genre_count - 1] = strdup(optarg);
+ 0
                break;
+ 0
			case 'h':
+ 0
				usage();
+ 0
				exit(0);
+ 0
				break;
+ 0
			case 'l':
+ 0
				opt->album = realloc(opt->album, (++opt->album_count)*sizeof(char *));
+ 0
				opt->album[opt->album_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
			case 's':
+ 0
				/* Would just use atoi(), but that doesn't deal with unsigned
+ 0
				 * ints. Damn */
+ 0
				opt->album = realloc(opt->album, (++opt->album_count)*sizeof(char *));
+ 0
					opt->serial = 0; /* Failed, so just set to zero */
+ 0
				break;
+ 0
			case 't':
+ 0
				opt->title = realloc(opt->title, (++opt->title_count)*sizeof(char *));
+ 0
				opt->title[opt->title_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
			case 'b':
+ 0
   				if(sscanf(optarg, "%d", &opt->nominal_bitrate)
+ 0
    					!= 1) {
+ 0
	    			fprintf(stderr, _("Warning: nominal bitrate \"%s\" not recognised\n"), optarg);
+ 0
		    		opt->nominal_bitrate = -1;
+ 0
				}
+ 0

+ 0
				break;
+ 0
			case 'M':
+ 0
				if(sscanf(optarg, "%d", &opt->max_bitrate)
+ 0
						!= 1) {
+ 0
					fprintf(stderr, _("Warning: maximum bitrate \"%s\" not recognised\n"), optarg);
+ 0
					opt->max_bitrate = -1;
+ 0
				}
+ 0
				if(!opt->managed){
+ 0
				  if(!opt->quiet)
+ 0
				    fprintf(stderr, 
+ 0
					    _("Enabling bitrate management engine\n"));
+ 0
				  opt->managed = 1;
+ 0
				}
+ 0
				break;
+ 0
			case 'q':
+ 0
				if(sscanf(optarg, "%f", &opt->quality) != 1) {
+ 0
					fprintf(stderr, _("Quality option \"%s\" not recognised, ignoring\n"), optarg);
+ 0
					break;
+ 0
				}
+ 0
				opt->quality_set=1;
+ 0
				opt->quality *= 0.1;
+ 0
				if(opt->quality > 1.0f)
+ 0
				{
+ 0
					opt->quality = 1.0f;
+ 0
					fprintf(stderr, _("WARNING: quality setting too high, setting to maximum quality.\n"));
+ 0
				}
+ 0
				break;
+ 0
			case 'n':
+ 0
				if(opt->namefmt)
+ 0
				{
+ 0
					fprintf(stderr, _("WARNING: Multiple name formats specified, using final\n"));
+ 0
					free(opt->namefmt);
+ 0
				}
+ 0
				opt->namefmt = strdup(optarg);
+ 0
				break;
+ 0
            case 'X':
+ 0
				if(opt->namefmt_remove && opt->namefmt_remove != 
+ 0
                        DEFAULT_NAMEFMT_REMOVE)
+ 0
				{
+ 0
					fprintf(stderr, _("WARNING: Multiple name format filters specified, using final\n"));
+ 0
					free(opt->namefmt_remove);
+ 0
				}
+ 0
				opt->namefmt_remove = strdup(optarg);
+ 0
				break;
+ 0
            case 'P':
+ 0
				if(opt->namefmt_replace && opt->namefmt_replace != 
+ 0
                        DEFAULT_NAMEFMT_REPLACE)
+ 0
                {
+ 0
					fprintf(stderr, _("WARNING: Multiple name format filter replacements specified, using final\n"));
+ 0
					free(opt->namefmt_replace);
+ 0
				}
+ 0
				opt->namefmt_replace = strdup(optarg);
+ 0
				break;
+ 0
			case 'o':
+ 0
				if(opt->outfile)
+ 0
				{
+ 0
					fprintf(stderr, _("WARNING: Multiple output files specified, suggest using -n\n"));
+ 0
					free(opt->outfile);
+ 0
				}
+ 0
				opt->outfile = strdup(optarg);
+ 0
				break;
+ 0
			case 'Q':
+ 0
				opt->quiet = 1;
+ 0
				break;
+ 0
			case 'r':
+ 0
				opt->rawmode = 1;
+ 0
				break;
+ 0
			case 'v':
+ 0
				fprintf(stdout, VERSION_STRING);
+ 0
				exit(0);
+ 0
				break;
+ 0
			case 'B':
+ 0
				if (opt->rawmode != 1)
+ 0
				{
+ 0
					opt->rawmode = 1;
+ 0
					fprintf(stderr, _("WARNING: Raw bits/sample specified for non-raw data. Assuming input is raw.\n"));
+ 0
				}
+ 0
				if(sscanf(optarg, "%u", &opt->raw_samplesize) != 1)
+ 0
				{
+ 0
					opt->raw_samplesize = 16; /* Failed, so just set to 16 */
+ 0
					fprintf(stderr, _("WARNING: Invalid bits/sample specified, assuming 16.\n"));
+ 0
				}
+ 0
				if((opt->raw_samplesize != 8) && (opt->raw_samplesize != 16))
+ 0
				{
+ 0
					fprintf(stderr, _("WARNING: Invalid bits/sample specified, assuming 16.\n"));
+ 0
				}
+ 0
				break;
+ 0
			case 'C':
+ 0
				if (opt->rawmode != 1)
+ 0
				{
+ 0
					opt->rawmode = 1;
+ 0
					fprintf(stderr, _("WARNING: Raw channel count specified for non-raw data. Assuming input is raw.\n"));
+ 0
				}
+ 0
				if(sscanf(optarg, "%u", &opt->raw_channels) != 1)
+ 0
				{
+ 0
					opt->raw_channels = 2; /* Failed, so just set to 2 */
+ 0
					fprintf(stderr, _("WARNING: Invalid channel count specified, assuming 2.\n"));
+ 0
				}
+ 0
				break;
+ 0
			case 'N':
+ 0
				opt->tracknum = realloc(opt->tracknum, (++opt->track_count)*sizeof(char *));
+ 0
				opt->tracknum[opt->track_count - 1] = strdup(optarg);
+ 0
				break;
+ 0
			case 'R':
+ 0
				if (opt->rawmode != 1)
+ 0
				{
+ 0
					opt->rawmode = 1;
+ 0
					fprintf(stderr, _("WARNING: Raw sample rate specified for non-raw data. Assuming input is raw.\n"));
+ 0
				}
+ 0
				if(sscanf(optarg, "%u", &opt->raw_samplerate) != 1)
+ 0
				{
+ 0
					opt->raw_samplerate = 44100; /* Failed, so just set to 44100 */
+ 0
					fprintf(stderr, _("WARNING: Invalid sample rate specified, assuming 44100.\n"));
+ 0
				}
+ 0
				break;
+ 0
			case '?':
+ 0
				fprintf(stderr, _("WARNING: Unknown option specified, ignoring->\n"));
+ 0
				break;
+ 0
			default:
+ 0
				usage();
+ 0
				exit(0);
+ 0
		}
+ 0
	}
+ 0

+ 0
}
+ 0

+ 0
static void add_tag(vorbis_comment *vc, oe_options *opt,char *name, char *value)
+ 0
{
+ 0
  if(name == NULL)
+ 0
    vorbis_comment_add(vc, value);
+ 0
  else
+ 0
    vorbis_comment_add_tag(vc, name, value);
+ 0
}
+ 0

+ 0
static void build_comments(vorbis_comment *vc, oe_options *opt, int filenum, 
+ 0
		char **artist, char **album, char **title, char **tracknum, 
+ 0
        char **date, char **genre)
+ 0
{
+ 0
	int i;
+ 0

+ 0
	vorbis_comment_init(vc);
+ 0

+ 0
	for(i = 0; i < opt->comment_count; i++)
+ 0
		add_tag(vc, opt, NULL, opt->comments[i]);
+ 0

+ 0
	if(opt->title_count)
+ 0
	{
+ 0
		if(filenum >= opt->title_count)
+ 0
		{
+ 0
			if(!opt->quiet)
+ 0
				fprintf(stderr, _("WARNING: Insufficient titles specified, defaulting to final title.\n"));
+ 0
			i = opt->title_count-1;
+ 0
		}
+ 0
		else
+ 0
			i = filenum;
+ 0

+ 0
		*title = opt->title[i];
+ 0
		add_tag(vc, opt, "title", opt->title[i]);
+ 0
	}
+ 0

+ 0
	if(opt->artist_count)
+ 0
	{
+ 0
		if(filenum >= opt->artist_count)
+ 0
			i = opt->artist_count-1;
+ 0
		else
+ 0
			i = filenum;
+ 0
	
+ 0
		*artist = opt->artist[i];
+ 0
		add_tag(vc, opt, "artist", opt->artist[i]);
+ 0
	}
+ 0

+ 0
    if(opt->genre_count)
+ 0
    {
+ 0
        if(filenum >= opt->genre_count)
+ 0
            i = opt->genre_count-1;
+ 0
        else
+ 0
            i = filenum;
+ 0

+ 0
        *genre = opt->genre[i];
+ 0
        add_tag(vc, opt, "genre", opt->genre[i]);
+ 0
    }
+ 0

+ 0
	if(opt->date_count)
+ 0
	{
+ 0
		if(filenum >= opt->date_count)
+ 0
			i = opt->date_count-1;
+ 0
		else
+ 0
			i = filenum;
+ 0
	
+ 0
		*date = opt->dates[i];
+ 0
		add_tag(vc, opt, "date", opt->dates[i]);
+ 0
	}
+ 0
	
+ 0
	if(opt->album_count)
+ 0
	{
+ 0
		if(filenum >= opt->album_count)
+ 0
		{
+ 0
			i = opt->album_count-1;
+ 0
		}
+ 0
		else
+ 0
			i = filenum;
+ 0

+ 0
		*album = opt->album[i];	
+ 0
		add_tag(vc, opt, "album", opt->album[i]);
+ 0
	}
+ 0

+ 0
	if(filenum < opt->track_count)
+ 0
	{
+ 0
		i = filenum;
+ 0
		*tracknum = opt->tracknum[i];
+ 0
		add_tag(vc, opt, "tracknumber", opt->tracknum[i]);
+ 0
	}
+ 0
}
+ 0

+ 1
 **
+ 1
 ** This program is distributed under the GNU General Public License, version 2.
+ 1
 ** A copy of this license is included with this source.
+ 1
 **
+ 1
 ** Copyright 2000-2002, Michael Smith <msmith@xiph.org>
+ 1
 **
+ 1
 ** AIFF/AIFC support from OggSquish, (c) 1994-1996 Monty <xiphmont@xiph.org>
+ 1
 **/
+ 1

+ 1
static int seek_forward(FILE *in, int length)
+ 1
{
+ 1
	if(fseek(in, length, SEEK_CUR))
+ 1
	{
+ 1
		/* Failed. Do it the hard way. */
+ 1
		unsigned char buf[1024];
+ 1
		int seek_needed = length, seeked;
+ 1
		while(seek_needed > 0)
+ 1
		{
+ 1
			seeked = fread(buf, 1, seek_needed>1024?1024:seek_needed, in);
+ 1
			if(!seeked)
+ 1
				return 0; /* Couldn't read more, can't read file */
+ 1
			else
+ 1
				seek_needed -= seeked;
+ 1
		}
+ 1
	}
+ 1
	return 1;
+ 1
}
+ 1

+ 1

+ 1

+ 1
/* This program is licensed under the GNU Library General Public License,
+ 1
 * version 2, a copy of which is included with this program (LICENCE.LGPL).
+ 1
 *   
+ 1
 * (c) 2002 Simon Hosie <gumboot@clear.net.nz>
+ 1
 *
+ 1
 *
+ 1
 * A resampler
+ 1
 *
+ 1
 * reference:
+ 1
 * 	'Digital Filters', third edition, by R. W. Hamming  ISBN 0-486-65088-X
+ 1
 *
+ 1
 * history:
+ 1
 *	2002-05-31	ready for the world (or some small section thereof)
+ 1
 *
+ 1
 *
+ 1
 * TOOD:
+ 1
 * 	zero-crossing clipping in coefficient table
+ 1
 */
+ 1

+ 1
#define _RESAMPLE_H_INCLUDED
+ 1

+ 1
typedef float SAMPLE;
+ 1

+ 1
typedef struct
+ 1
{
+ 1
	unsigned int channels, infreq, outfreq, taps;
+ 1
	float *table;
+ 1
	SAMPLE *pool;
+ 1

+ 1
	/* dynamic bits */
+ 1
	int poolfill;
+ 1
	int offset;
+ 1
} res_state;
+ 1

+ 1
typedef enum
+ 1
{
+ 1
	RES_END,
+ 1
	RES_GAIN,	/* (double)1.0 */
+ 1
	RES_CUTOFF,	/* (double)0.80 */ 
+ 1
	RES_TAPS,	/* (int)45 */
+ 1
	RES_BETA	/* (double)16.0 */
+ 1
} res_parameter;
+ 1

+ 1
int res_init(res_state *state, int channels, int outfreq, int infreq, res_parameter op1, ...);
+ 1
/*
+ 1
 * Configure *state to manage a data stream with the specified parameters.  The
+ 1
 * string 'params' is currently unspecified, but will configure the parameters
+ 1
 * of the filter.
+ 1
 *
+ 1
 * This function allocates memory, and requires that res_clear() be called when
+ 1
 * the buffer is no longer needed.
+ 1
 *
+ 1
 *
+ 1
 * All counts/lengths used in the following functions consider only the data in
+ 1
 * a single channel, and in numbers of samples rather than bytes, even though
+ 1
 * functionality will be mirrored across as many channels as specified here.
+ 1
 */
+ 1

+ 1

+ 1
int res_push_max_input(res_state const *state, size_t maxoutput);
+ 1
/*
+ 1
 *  Returns the maximum number of input elements that may be provided without
+ 1
 *  risk of flooding an output buffer of size maxoutput.  maxoutput is
+ 1
 *  specified in counts of elements, NOT in bytes.
+ 1
 */
+ 1

+ 1

+ 1
int res_push_check(res_state const *state, size_t srclen);
+ 1
/*
+ 1
 * Returns the number of elements that will be returned if the given srclen
+ 1
 * is used in the next call to res_push().
+ 1
 */
+ 1

+ 1

+ 1
int res_push(res_state *state, SAMPLE **dstlist, SAMPLE const **srclist, size_t srclen);
+ 1
int res_push_interleaved(res_state *state, SAMPLE *dest, SAMPLE const *source, size_t srclen);
+ 1
/*
+ 1
 * Pushes srclen samples into the front end of the filter, and returns the
+ 1
 * number of resulting samples.
+ 1
 *
+ 1
 * res_push(): srclist and dstlist point to lists of pointers, each of which
+ 1
 * indicates the beginning of a list of samples.
+ 1
 *
+ 1
 * res_push_interleaved(): source and dest point to the beginning of a list of
+ 1
 * interleaved samples.
+ 1
 */
+ 1

+ 1

+ 1
int res_drain(res_state *state, SAMPLE **dstlist);
+ 1
int res_drain_interleaved(res_state *state, SAMPLE *dest);
+ 1
/*
+ 1
 * Recover the remaining elements by flushing the internal pool with 0 values,
+ 1
 * and storing the resulting samples.
+ 1
 *
+ 1
 * After either of these functions are called, *state should only re-used in a
+ 1
 * final call to res_clear().
+ 1
 */
+ 1

+ 1

+ 1
void res_clear(res_state *state);
+ 1
/*
+ 1
 * Free allocated buffers, etc.
+ 1
 */
+ 1

+ 1
#define WAV_HEADER_SIZE 44
+ 1

+ 1
/* Macros to read header data */
+ 1
#define READ_U32_LE(buf) \
+ 1
	(((buf)[3]<<24)|((buf)[2]<<16)|((buf)[1]<<8)|((buf)[0]&0xff))
+ 1

+ 1
#define READ_U16_LE(buf) \
+ 1
	(((buf)[1]<<8)|((buf)[0]&0xff))
+ 1

+ 1
#define READ_U32_BE(buf) \
+ 1
	(((buf)[0]<<24)|((buf)[1]<<16)|((buf)[2]<<8)|((buf)[3]&0xff))
+ 1

+ 1
#define READ_U16_BE(buf) \
+ 1
	(((buf)[0]<<8)|((buf)[1]&0xff))
+ 1

+ 1
/* Define the supported formats here */
+ 1
input_format formats[] = {
+ 1
	{wav_id, 12, wav_open, wav_close, "wav", N_("WAV file reader")},
+ 1
	{aiff_id, 12, aiff_open, wav_close, "aiff", N_("AIFF/AIFC file reader")},
+ 1
#ifdef HAVE_LIBFLAC
+ 1
	{flac_id,     4, flac_open, flac_close, "flac", N_("FLAC file reader")},
+ 1
	{oggflac_id, 32, flac_open, flac_close, "ogg", N_("Ogg FLAC file reader")},
+ 1
#endif
+ 1
	{NULL, 0, NULL, NULL, NULL, NULL}
+ 1
};
+ 1

+ 1
input_format *open_audio_file(FILE *in, oe_enc_opt *opt)
+ 1
{
+ 1
	int j=0;
+ 1
	unsigned char *buf=NULL;
+ 1
	int buf_size=0, buf_filled=0;
+ 1
	int size,ret;
+ 1

+ 1
	while(formats[j].id_func)
+ 1
	{
+ 1
		size = formats[j].id_data_len;
+ 1
		if(size >= buf_size)
+ 1
		{
+ 1
			buf = realloc(buf, size);
+ 1
			buf_size = size;
+ 1
		}
+ 1

+ 1
		if(size > buf_filled)
+ 1
		{
+ 1
			ret = fread(buf+buf_filled, 1, buf_size-buf_filled, in);
+ 1
			buf_filled += ret;
+ 1

+ 1
			if(buf_filled < size)
+ 1
			{ /* File truncated */
+ 1
				j++;
+ 1
				continue;
+ 1
			}
+ 1
		}
+ 1

+ 1
		if(formats[j].id_func(buf, buf_filled))
+ 1
		{
+ 1
			/* ok, we now have something that can handle the file */
+ 1
			if(formats[j].open_func(in, opt, buf, buf_filled)) {
+ 1
                free(buf);
+ 1
				return &formats[j];
+ 1
            }
+ 1
		}
+ 1
		j++;
+ 1
	}
+ 1

+ 1
    free(buf);
+ 1

+ 1
	return NULL;
+ 1
}
+ 1

+ 1
static int seek_forward(FILE *in, int length)
+ 1
{
+ 1
	if(fseek(in, length, SEEK_CUR))
+ 1
	{
+ 1
		/* Failed. Do it the hard way. */
+ 1
		unsigned char buf[1024];
+ 1
		int seek_needed = length, seeked;
+ 1
		while(seek_needed > 0)
+ 1
		{
+ 1
			seeked = fread(buf, 1, seek_needed>1024?1024:seek_needed, in);
+ 1
			if(!seeked)
+ 1
				return 0; /* Couldn't read more, can't read file */
+ 1
			else
+ 1
				seek_needed -= seeked;
+ 1
		}
+ 1
	}
+ 1
	return 1;
+ 1
}
+ 1

+ 1

+ 1
static int find_wav_chunk(FILE *in, char *type, unsigned int *len)
+ 1
{
+ 1
	unsigned char buf[8];
+ 1

+ 1
	while(1)
+ 1
	{
+ 1
		if(fread(buf,1,8,in) < 8) /* Suck down a chunk specifier */
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: Unexpected EOF in reading WAV header\n"));
+ 1
			return 0; /* EOF before reaching the appropriate chunk */
+ 1
		}
+ 1

+ 1
		if(memcmp(buf, type, 4))
+ 1
		{
+ 1
			*len = READ_U32_LE(buf+4);
+ 1
			if(!seek_forward(in, *len))
+ 1
				return 0;
+ 1

+ 1
			buf[4] = 0;
+ 1
			fprintf(stderr, _("Skipping chunk of type \"%s\", length %d\n"), buf, *len);
+ 1
		}
+ 1
		else
+ 1
		{
+ 1
			*len = READ_U32_LE(buf+4);
+ 1
			return 0;
+ 1
		}
+ 1
	}
+ 1
}
+ 1

+ 1
int find_aiff_chunk(FILE *in, char *type, unsigned int *len)
+ 1
{
+ 1
	unsigned char buf[8];
+ 1

+ 1
	while(1)
+ 1
	{
+ 1
		if(fread(buf,1,8,in) <8)
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: Unexpected EOF in AIFF chunk\n"));
+ 1
			return 0;
+ 1
		}
+ 1

+ 1
		*len = READ_U32_BE(buf+4);
+ 1

+ 1
		if(memcmp(buf,type,4))
+ 1
		{
+ 1
			if((*len) & 0x1)
+ 1
				(*len)++;
+ 1

+ 1
			if(!seek_forward(in, *len))
+ 1
				return 0;
+ 1
		}
+ 1
		else
+ 1
			return 1;
+ 1
	}
+ 1
}
+ 1

+ 1
aiff->bigendian = 1;
+ 1

+ 1
	if(aifc)
+ 1
	{
+ 1
		if(len < 22)
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: AIFF-C header truncated.\n"));
+ 1
			return 0;
+ 1
		}
+ 1

+ 1
		if(!memcmp(buffer+18, "NONE", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 1;
+ 1
		}
+ 1
		else if(!memcmp(buffer+18, "sowt", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 0;
+ 1
		}
+ 1
		else
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: Can't handle compressed AIFF-C (%c%c%c%c)\n"), *(buffer+18), *(buffer+19), *(buffer+20), *(buffer+21));
+ 1
			return 0; /* Compressed. Can't handle */
+ 1
		}
+ 1
	}
+ 1

+ 1
	if(!find_aiff_chunk(in, "SSND", &len))
+ 1
	{
+ 1
		fprintf(stderr, _("Warning: No SSND chunk found in AIFF file\n"));
+ 1
		return 0; /* No SSND chunk -> no actual audio */
+ 1
	}
+ 1

+ 1

+ 1

+ 1
double read_IEEE80(unsigned char *buf)
+ 1
{
+ 1
	int s=buf[0]&0xff;
+ 1
	int e=((buf[0]&0x7f)<<8)|(buf[1]&0xff);
+ 1
	double f=((unsigned long)(buf[2]&0xff)<<24)|
+ 1
		((buf[3]&0xff)<<16)|
+ 1
		((buf[4]&0xff)<<8) |
+ 1
		 (buf[5]&0xff);
+ 1

+ 1
	if(e==32767)
+ 1
	{
+ 1
		if(buf[2]&0x80)
+ 1
			return HUGE_VAL; /* Really NaN, but this won't happen in reality */
+ 1
		else
+ 1
		{
+ 1
			if(s)
+ 1
				return -HUGE_VAL;
+ 1
			else
+ 1
				return HUGE_VAL;
+ 1
		}
+ 1
	}
+ 1

+ 1
	f=ldexp(f,32);
+ 1
	f+= ((buf[6]&0xff)<<24)|
+ 1
		((buf[7]&0xff)<<16)|
+ 1
		((buf[8]&0xff)<<8) |
+ 1
		 (buf[9]&0xff);
+ 1

+ 1
	return ldexp(f, e-16446);
+ 1
}
+ 1

+ 1
/* AIFF/AIFC support adapted from the old OggSQUISH application */
+ 1
int aiff_id(unsigned char *buf, int len)
+ 1
{
+ 1
	if(len<12) return 0; /* Truncated file, probably */
+ 1

+ 1
	if(memcmp(buf, "FORM", 4))
+ 1
		return 0;
+ 1

+ 1
	if(memcmp(buf+8, "AIF",3))
+ 1
		return 0;
+ 1

+ 1
	if(buf[11]!='C' && buf[11]!='F')
+ 1
		return 0;
+ 1

+ 1
	return 1;
+ 1
}
+ 1

+ 1
int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen)
+ 1
{
+ 1
	int aifc; /* AIFC or AIFF? */
+ 1
	unsigned int len;
+ 1
	unsigned char *buffer;
+ 1
	unsigned char buf2[8];
+ 1
	aiff_fmt format;
+ 1
	aifffile *aiff = malloc(sizeof(aifffile));
+ 1

+ 1
	if(buf[11]=='C')
+ 1
		aifc=0;
+ 1
	else
+ 1
		aifc=1;
+ 1

+ 1
	if(!find_aiff_chunk(in, "COMM", &len))
+ 1
	{
+ 1
		fprintf(stderr, _("Warning: No common chunk found in AIFF file\n"));
+ 1
		return 0; /* EOF before COMM chunk */
+ 1
	}
+ 1

+ 1
	if(len < 18) 
+ 1
	{
+ 1
		fprintf(stderr, _("Warning: Truncated common chunk in AIFF header\n"));
+ 1
		return 0; /* Weird common chunk */
+ 1
	}
+ 1

+ 1
	buffer = alloca(len);
+ 1

+ 1
	if(fread(buffer,1,len,in) < len)
+ 1
	{
+ 1
		fprintf(stderr, _("Warning: Unexpected EOF in reading AIFF header\n"));
+ 1
		return 0;
+ 1
	}
+ 1
	
+ 1
	if(aifc)
+ 1
	{
+ 1
		if(len < 22)
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: AIFF-C header truncated.\n"));
+ 1
			return 0;
+ 1
		}
+ 1

+ 1
		if(!memcmp(buffer+18, "NONE", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 1;
+ 1
		}
+ 1
		else if(!memcmp(buffer+18, "sowt", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 0;
+ 1
		}
+ 1
		else
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: Can't handle compressed AIFF-C (%c%c%c%c)\n"), *(buffer+18), *(buffer+19), *(buffer+20), *(buffer+21));
+ 1
			return 0; /* Compressed. Can't handle */
+ 1
		}
+ 1
	}
+ 1

+ 1

+ 1
	format.channels = READ_U16_BE(buffer);
+ 1
	format.totalframes = READ_U32_BE(buffer+2);
+ 1
	format.samplesize = READ_U16_BE(buffer+6);
+ 1
	format.rate = (int)read_IEEE80(buffer+8);
+ 1

+ 1
    aiff->bigendian = 1;
+ 1

+ 1
	if(aifc)
+ 1
	{
+ 1
		if(len < 22)
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: AIFF-C header truncated.\n"));
+ 1
			return 0;
+ 1
		}
+ 1

+ 1
		if(!memcmp(buffer+18, "NONE", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 1;
+ 1
		}
+ 1
		else if(!memcmp(buffer+18, "sowt", 4)) 
+ 1
		{
+ 1
			aiff->bigendian = 0;
+ 1
		}
+ 1
		else
+ 1
		{
+ 1
			fprintf(stderr, _("Warning: Can't handle compressed AIFF-C (%c%c%c%c)\n"), *(buffer+18), *(buffer+19), *(buffer+20), *(buffer+21));
+ 1
			return 0; /* Compressed. Can't handle */
+ 1
		}
+ 1
	}
+ 1

+ 1
	if(!find_aiff_chunk(in, "SSND", &len))
+ 1
	{
+ 1
		fprintf(stderr, _("Warning: No SSND chunk found in AIFF file\n"));
+ 1
		return 0; /* No SSND chunk -> no actual audio */
+ 1
	}
+ 1

+ 1
	elif(fread(buf2,1,8, in) < 8)
+ 1
	{
+ 1
		printf(stderr, _("Warning: Unexpected EOF reading AIFF header\n"));
+ 1
		return 0;
+ 1
	}
+ 1

D 2 2024
= 2035
		aiff->f = in;
+ 2035
		aiff->samplesread = 0;
+ 2035
		aiff->channels = format.channels;
+ 2035
		aiff->samplesize = format.samplesize;
+ 2035
		aiff->totalsamples = format.totalframes;
+ 2036
pt->total_samples_per_channel = format.totalframes;
+ 2036

